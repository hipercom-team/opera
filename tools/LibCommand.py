#---------------------------------------------------------------------------
#                                 OPERA
#---------------------------------------------------------------------------
# Author: Cedric Adjih
# Copyright 2011 Inria.
#
# This file is part of the OPERA.
#
# The OPERA is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# The OPERA is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
# License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with the OPERA; see the file LICENSE.LGPLv3.  If not, see
# http://www.gnu.org/licenses/ or write to the Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA. 
#---------------------------------------------------------------------------

import struct, sys

try: 
    import hipsens
    from hipsens import OPERA_INCREASE_TREE_SEQNUM, OPERA_CMD_GET_VERSION
    from hipsens import OPERA_ADDRESS_FILTER_SET
    from hipsens import FilterOnlyAccept, FilterReject, FilterNone
except:
    print "*** Note: module 'hipsens' not imported, reading from 'genHipsens'"
    import genHipsens as hipsens
    from genHipsens import *
    
#---------------------------------------------------------------------------

CmdOpera = 0xfe

def p(*args): return struct.pack(*args)

def packCommand(data):
    cmd = struct.pack("BB", 1+len(data), CmdOpera) + data
    return cmd

def cmdVersion():
    return packCommand(p("B",OPERA_CMD_GET_VERSION))

OperaGetCode = {}
OperaSetCode = {}
OperaNameList = []

for name in dir(hipsens):
    originalName = name
    if name.startswith("OPERA_GET_"):
        name = name.replace("OPERA_GET_", "")
        table = OperaGetCode
    elif name.startswith("OPERA_SET_"):
        name = name.replace("OPERA_SET_", "")
        table = OperaSetCode
    else: continue
    if not name.endswith("START_DELAY"):
        if name.startswith("EOND_"): name = name.replace("EOND_", "")
        if name.startswith("EOSTC_"): name = name.replace("EOSTC_", "")
        if name.startswith("SERENA_"): name = name.replace("SERENA_", "")
    name = name.lower().replace("_", "-")
    table[name] = getattr(hipsens, originalName)
    OperaNameList.append(originalName)

def cmdSet(name, value):
    if OperaSetCode.has_key(name):
        return packCommand(p("BH", OperaSetCode[name], value))
    else: raise ValueError("Unknown attribute", name)

def cmdGet(name):
    if OperaGetCode.has_key(name):
        return packCommand(p("B", OperaGetCode[name]))
    else: raise ValueError("Unknown attribute", name)

def makeCommand(*arg):
    if arg[0] == "set":
        arg = list(arg)
        if type(arg[2]) == str:
            arg[2] = eval(arg[2])
        return cmdSet(arg[1], arg[2])
    elif arg[0] == "get":
        return cmdGet(arg[1])
    elif arg[0] == "start-eostc":
        if type(arg[1]) != int:
            argl = list(arg)
            argl[1] = int(argl[1])
            arg = tuple(argl)
        return makeCommand(*(("set", "my-tree") + arg[1:]))
    elif arg[0] == "next-eostc":
        return packCommand(p("B", OPERA_INCREASE_TREE_SEQNUM))
    elif arg[0] == "address-filter":
        if arg[1] == "accept": mode = FilterOnlyAccept
        elif arg[1] == "reject": mode = FilterReject
        elif arg[1] == "none": mode = FilterNone
        addressList = [ struct.pack("!H",x) if (type(x) == type(int)) 
                        else struct.pack("H",eval(x))
                        for x in arg[2:] ]
        data = "".join(addressList) #struct.pack("!H", x) for x in addressList)
        return packCommand(p("BB", OPERA_ADDRESS_FILTER_SET, mode) 
                           + data)

    else: raise ValueError("Unknown command", arg)

#---------------------------------------------------------------------------

def generateReplacementModule():
    f = open("genHipsens.py", "w")
    f.write("#--- file automatically generated by:\n")
    f.write("#---   python %s\n" % (" ".join(sys.argv)))
    for name in ["OPERA_INCREASE_TREE_SEQNUM", 
                 "OPERA_CMD_GET_VERSION",
                 "OPERA_ADDRESS_FILTER_SET", 
                 "FilterOnlyAccept", "FilterReject", "FilterNone" ]:        
        f.write("%s = %s\n" % (name, eval(name)))
    for name in OperaNameList:
        f.write("%s = %s\n" % (name, eval("hipsens."+name)))
    f.close()

#---------------------------------------------------------------------------

if __name__ == "__main__":
    if "generate" in sys.argv:
        generateReplacementModule()

#---------------------------------------------------------------------------

